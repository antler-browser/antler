# CLAUDE.md for React Native App

This file provides guidance to Claude Code (claude.ai/code) when working with the React Native app code in this repository.

## Project Overview
Antler is a super-powered QR scanner for IRL hangouts. Available on iOS and Android (React Native + Expo), it lets users create profiles (with DIDs), scan QR codes, and instantly access mini web apps through a WebView — no signup required.

For developers, Antler is a mobile SDK that provides a WebView environment for mini apps. Build simple, self-contained web apps that know users are physically present and can scan QR codes — no native code, no app stores, no auth systems needed.

Antler implements the **IRL Browser Standard**, a specification that defines how IRL Browsers communicate with third-party web applications (mini apps) through signed JWTs and a JavaScript API (`window.irlBrowser`). See `/docs/irl-browser-standard.md` for full specification.

## Key Files and Directories

### Application Structure
- `/app/screens/`: Screen components for each route
  - `/profile/`: Profile creation and viewing screens (NameScreen, SocialsScreen, AvatarScreen, ProfileScreen)
  - `/onboarding/`: Onboarding flow screens (WelcomeScreen, OnboardingNavigator)
  - `CameraScreen.tsx`: Main camera screen with QR scanning
  - `WebViewScreen.tsx`: IRL Browser container that injects `window.irlBrowser` API and handles bidirectional communication with mini apps
  - `SettingsScreen.tsx`: Settings modal with app info and support links (Privacy Policy, Terms of Service, Rate App, Email Support)
  - `ModalStackNavigator.tsx`: Modal navigation stack
  - `root.tsx`: Root navigation configuration
- `/app/components/`: Components organized by feature
  - `/camera/`: Camera-related components (CameraView with flash/settings controls, CameraPermissions, ProfileCarousel, ProfileOverlay)
  - `/ui/`: Shared UI components (ThemedView, ThemedText, ThemedButton, etc.)
- `/app/hooks/`: Custom React hooks
  - `useOnboarding.ts`: Onboarding state management
  - `useProfile.ts`: Profile data management
- `/lib/`: Utilities and service integrations
  - `camera.ts`: Camera and QR scanning utilities
  - `did.ts`: Decentralized identity (DID) utilities
  - `send-data.ts`: JWT signing utilities for WebView communication (IRL Browser Standard)
  - `secure-storage.ts`: Secure storage operations
  - `social-links.ts`: Social media link validation and formatting
  - `colors.ts`: Color constants
  - `navigation.ts`: Navigation types and constants
  - `/webview/`: WebView integration files
    - `webview-signing.ts`: Ephemeral ECDSA P-256 key pair generation and message signing for WebView XSS protection
    - `webview-injected.ts`: WebView JavaScript injection module (imports pre-minified code)
    - `webview-injected.raw.js`: Raw JavaScript template for WebView API with XSS protection (Object.defineProperty + Object.freeze to prevent API tampering, source for minification)
    - `webview-injected.min.ts`: Minified WebView JavaScript (auto-generated by `yarn minify-webview`)
    - `webview-console-intercept.raw.js`: Console forwarding code (disabled by default)
    - `webview-console-intercept.min.ts`: Minified console intercept code (auto-generated)
    - `manifest.ts`: Manifest fetching and validation with UGC protection (HTML tag stripping, length limits, URL validation)
  - `/db/`: Database schema, migrations, and model operations
    - `schema.ts`: Drizzle schema definitions
    - `index.ts`: Database connection and migration runner
    - `/migrations/`: SQL migration files
    - `/models/`: Database model operations (AppStateFns, UserProfileFns, ScanHistoryFns)
- `/docs/`: Documentation
  - `irl-browser-standard.md`: IRL Browser Standard specification
  - `webview-console-forwarding.md`: Guide for re-enabling console log forwarding from WebView
- `/scripts/`: Build scripts
  - `minify-webview-js.js`: Build script to minify the WebView injected JavaScript
- `/__tests__/`: Test suites
  - `/lib/webview/manifest.test.ts`: Manifest validation tests
  - `/lib/webview/webview-injected.test.ts`: WebView API injection tests (signature verification, XSS protection, API functionality)
  - `/lib/send-data.test.ts`: JWT signing and data transfer tests
  - `/lib/social-links.test.ts`: Social links validation and formatting tests
- `/assets/`: Static assets (fonts, icons, images)
- `index.tsx`: App entry point
- `app.config.js`: Expo configuration
- `tsconfig.json`: TypeScript configuration

## Development Commands

```bash
# Install dependencies
yarn install

# Start development server
yarn dev

# Add new package
yarn add <package-name>

# Minify WebView injected JavaScript (run after editing raw templates)
yarn minify-webview

# Type checking (also runs minify-webview automatically)
yarn build

# Run on iOS simulator
yarn ios

# Run on Android emulator
yarn android

# Run tests
yarn test

# Run tests in watch mode
yarn test:watch

# Generate test coverage
yarn test:coverage

# Lint code
yarn lint
```

## Architecture Patterns

### Navigation Structure
- Stack-based navigation with camera as the root screen
- Modal presentations for profile creation and viewing
- Three main navigation stacks:
  1. **Camera Stack** (root): CameraScreen → ProfileScreen (modal)
  2. **Modal Stack**: Profile creation flow, WebView, and Settings
  3. **Onboarding Stack**: First-time user experience
- Navigation types and constants in `/lib/navigation.ts`
- Deep linking support through Expo Linking
- Navigation param lists:
  - `RootStackParamList`: Main app navigation
  - `ModalStackParamList`: Modal screens (profile form, webview, settings)
  - `ProfileCreateOrEditStackParamList`: Profile form flow (Name → Socials → Avatar) - used for both creating and editing profiles
  - `OnboardingStackParamList`: Onboarding screens

### Component Organization
- Feature-based organization (`/camera`, `/profile`, `/onboarding`)
- Common UI components in `/ui` directory
- Screen components handle routing logic
- Themed components for consistent styling across light/dark modes

### State Management
- Custom hooks for feature-specific state (`useOnboarding`, `useProfile`)
- SQLite database for app data persistence
- Platform-specific secure storage for DID private keys (SecureStore on iOS, AsyncStorage on Android)
- Context providers for theme

### Storage Architecture
- **SQLite Database**: User profiles, app state, social links, scan history
- **Secure Key Storage (Platform-Specific)**: DID private keys (Ed25519) used for signing JWTs
  - **iOS**: Uses Expo SecureStore (Keychain) with `AFTER_FIRST_UNLOCK` + `requireAuthentication: true`
    - Keys backed up to iTunes/Finder and iCloud
    - Requires biometric authentication (Face ID/Touch ID) to access
  - **Android**: Uses AsyncStorage instead of SecureStore
    - Keys backed up via Android Auto Backup to Google Drive
    - Keys are encrypted by Android's OS-level encryption and Google's backup encryption (AES-256)
    - Necessary because Android Keystore keys are hardware-bound and cannot be backed up
- Database managed with Drizzle ORM for type-safe queries
- Database model operations in `/lib/db/models/` organized by entity:
  - `app-state.ts`: AppStateFns namespace for app state operations
  - `user-profile.ts`: UserProfileFns namespace for profile CRUD
  - `scan-history.ts`: ScanHistoryFns namespace for scan tracking
- Secure storage utilities in `/lib/secure-storage.ts` (handles platform-specific logic)
- JWT signing utilities in `/lib/send-data.ts` for WebView communication

### Backup & Restore Behavior

#### Overview
Both the SQLite database and DID private keys are automatically backed up on iOS and Android, ensuring users don't lose their identity when upgrading devices or restoring from backup.

#### iOS Backup
- **Database**: Automatically backed up to iCloud Backup and iTunes/Finder backups
  - Stored in Documents directory (backed up by default)
  - No configuration needed
- **DID Keys**: Automatically backed up via Keychain
  - `AFTER_FIRST_UNLOCK` accessibility allows backup to iTunes/Finder
  - iCloud Keychain sync available if user enables it
  - Biometric protection maintained after restore
- **Requirements**: User must have iCloud Backup or iTunes/Finder backup enabled

#### Android Backup
- **Database**: Automatically backed up via Android Auto Backup to Google Drive
  - App has `android:allowBackup="true"` enabled
  - Database files in internal storage are included by default
  - Backups occur automatically when device is idle, charging, and on Wi-Fi
- **DID Keys**: Backed up via AsyncStorage (included in Auto Backup)
  - SecureStore (Android Keystore) explicitly excluded from backup (hardware-bound keys)
  - AsyncStorage provides automatic backup while sacrificing hardware backing
  - Protected by OS-level file encryption + Google's backup encryption (AES-256)
- **Requirements**:
  - Android 6.0+ (API level 23)
  - User has Google account with backup enabled
  - Under 25MB backup limit per app

#### User Scenarios

**✅ Data Preserved:**
- User loses phone and restores from backup → Full data restored (profiles + keys)
- User gets new phone and restores from backup → Full data restored
- User factory resets device and restores from backup → Full data restored

**❌ Data Lost:**
- User deletes and reinstalls app without restoring from backup → Fresh start
- User has backups disabled on device → Fresh start
- User exceeds 25MB limit on Android (unlikely for typical usage)

#### Security Implications
- **iOS**: Keys stored in hardware-backed Keychain with biometric protection + encrypted backups (strong security)
- **Android**: Keys stored in AsyncStorage with OS encryption + cloud backup encryption (trade-off for recoverability)
- This approach prioritizes user experience (maintaining identity across devices) over maximum security, which is appropriate for a social identity app (not a crypto wallet)

#### Testing Backup/Restore
To verify backup functionality:
1. Create a profile with DID in the app
2. Trigger a backup (iCloud/iTunes on iOS, Auto Backup on Android)
3. Delete the app or reset device
4. Restore from backup
5. Verify profile data and ability to sign JWTs (keys restored correctly)

### Database Structure
- **`app_state`**: Global application state (current DID, welcome completion)
- **`user_profiles`**: User profile data (DID, name, avatar, position, timestamps)
- **`social_links`**: Social media links (platform, handle, profile DID)
- **`scan_history`**: QR scan history with mini app manifest data
- Automatic migrations run on app startup
- Foreign key constraints with cascade deletes
- Position-based ordering for profiles

### Database API
Database operations are organized into function namespaces by entity:
- `UserProfileFns`: Profile CRUD operations
- `AppStateFns`: App state CRUD operations
- `ScanHistoryFns`: Scan history CRUD operations
- `SocialLinkFns`: Social media link CRUD operations

## Development Workflow

### Adding New Screens
1. Create screen component in appropriate directory under `/app/screens/`
2. Add screen to navigation stack in `/app/screens/root.tsx` or appropriate navigator
3. Add route types to `/lib/navigation.ts` param lists
4. Export navigation constants in `/lib/navigation.ts`

### Creating New Components
1. Add component to appropriate feature directory (`/camera`, `/profile`, etc.)
2. Use themed components from `/app/components/ui/` for consistent theming
3. Follow existing patterns for styling and props
4. Export component if needed through feature directory index file

### Theming
1. Theme values in `/lib/colors.ts`
2. Use themed components from `/app/components/ui/` when possible
3. All themed components support both light and dark mode
4. Available themed components:
   - `ThemedView`, `ThemedText`, `ThemedButton`, `ThemedTextInput`
   - `HeaderBackButton`, `HeaderCloseButton`
   - `ProgressIndicator`, `Screen`

### Onboarding for new app downloads
- Onboarding state managed by `useOnboarding` hook
- First-time user experience starts with WelcomeScreen
- Completion state persisted in SQLite database
- Database migrations run automatically during initialization

### Creating a Profile
- The profile creation flow is a three-step modal flow (Name → Socials → Avatar) with progress indicator, data validation at each step, and SQLite database persistence
- If a user does not have a profile, the first time you scan a QR code, the app will navigate to the profile creation flow
- Profile creation generates a DID (Decentralized Identifier) with private key stored securely (Keychain on iOS, AsyncStorage on Android)
- Profile data (name, avatar, social links) stored in SQLite via `UserProfileFns.createProfileByDid()`
- Profiles are a visual wrapper around a user's DID

### Camera & QR Scanning
- Camera permissions handled by `CameraPermissions` component
- QR scanning implemented in `CameraView`
- Scanned QR codes resolve DIDs to load profiles
- Camera utilities in `/lib/camera.ts`
- When a QR code is scanned, if the user has a profile:
  - App navigates to WebViewScreen with the URL and user's DID
  - The DID is used to fetch profile data and sign JWTs for mini app communication
  - Scan is tracked only if mini app has a valid manifest (regular QR codes not tracked)

### DID Integration
- Decentralized Identity (DID) utilities in `/lib/did.ts`
- DIDs used for user identification and profile resolution
- Private keys stored platform-specifically (iOS Keychain via SecureStore, Android AsyncStorage)
- JWT signing and verification supported using Ed25519 algorithm

### WebView & Mini App Integration
- Implements the IRL Browser Standard for secure communication with third-party mini apps
- **JavaScript API Injection** (`/app/screens/WebViewScreen.tsx`):
  - `window.irlBrowser.getProfileDetails()`: Returns signed JWT with user profile (async)
  - `window.irlBrowser.getAvatar()`: Returns signed JWT with user avatar or null (async)
  - `window.irlBrowser.getBrowserDetails()`: Returns browser info (name, version, platform, permissions)
  - `window.irlBrowser.requestPermission(permission)`: Request additional permissions (future)
  - `window.irlBrowser.close()`: Close WebView and return to camera
- **Message Handling**: WebViewScreen listens for messages from mini apps via `window.postMessage`
- **Manifest Fetching & Scan Tracking** (`/lib/webview/manifest.ts`):
  - Automatically fetches mini app manifest after page loads
  - Parses HTML for `<link rel="irl-manifest">` tag per IRL Browser Standard
  - Validates and sanitizes manifest data (UGC protection):
    - Strips HTML tags to prevent XSS
    - Enforces max length limits (name: 100, description: 500, location: 200, icon: 2048, type: 50)
    - Validates icon URLs are HTTPS only
    - Validates type is from allowed list (place, event, club, store, venue, experience)
  - If manifest is valid: Saves scan to `scan_history` with manifest snapshot (name, description, location, icon, type)
  - If manifest missing/invalid: Does not save scan (regular QR codes not tracked)
  - Silent fail - doesn't disrupt user experience
- **Minified JavaScript Injection** (`/lib/webview/webview-injected.ts`):
  - Injected JavaScript is pre-minified at build time using esbuild (59% smaller)
  - Raw templates: `lib/webview/webview-injected.raw.js` and `lib/webview/webview-console-intercept.raw.js`
  - Minified outputs: `lib/webview/webview-injected.min.ts` and `lib/webview/webview-console-intercept.min.ts` (auto-generated)
  - Run `yarn minify-webview` after editing raw templates
- **JWT Signing** (`/lib/send-data.ts`):
  - `getProfileDetailsJWT(did)`: Generates signed JWT for `getProfileDetails()` API responses
  - `getAvatarJWT(did)`: Generates signed JWT for `getAvatar()` API responses
  - `sendDataToWebView(type, did)`: Generates signed JWT for events (e.g., profile disconnect)
  - Uses Ed25519 algorithm with user's DID private key
  - JWTs include claims: `iss` (issuer DID), `iat` (issued at), `exp` (expiration), `type` (message type), `data` (payload)
- **Event Types**:
  - `irl:profile:disconnected`: Sent when user closes WebView
  - `irl:error`: Error data from native app
- Mini apps verify JWTs using the DID public key (`iss` field) to ensure authenticity
- See `/docs/irl-browser-standard.md` for full specification
- **Security Architecture**:
  - **Dual Signing System**:
    - Profile JWTs: Signed with user's DID private key (Ed25519, long-lived, platform-specific storage)
    - WebView internal messages: Signed with ephemeral ECDSA P-256 keys (session-only, prevents XSS)
  - **XSS Protection** (`/lib/webview/webview-signing.ts`):
    - Fresh ECDSA P-256 key pair generated per WebView session
    - Public key injected into WebView for signature verification
    - All native→WebView internal messages signed to prevent XSS forgery attacks
    - WebView verifies signatures using `crypto.subtle` with ECDSA P-256
    - Uses sorted keys for deterministic serialization to ensure signature verification works correctly
  - **Browser Requirements**:
    - Requires `crypto.subtle` with ECDSA P-256 support
    - iOS 11+ (Safari 11)
    - Android 5.0+ (Lollipop) with system WebView
  - `window.ReactNativeWebView.postMessage()` is a one-way secure channel (WebView → Native)

## Third Party Libraries
- Expo Camera for QR scanning and photo capture
- Expo Image Picker for avatar selection
- react-native-webview for WebView screen
- expo-sqlite with Drizzle ORM for local database (type-safe queries and migrations)
- Expo SecureStore for DID private keys (iOS only - uses Keychain)
- @react-native-async-storage/async-storage for DID private keys (Android only - backupable)
- @stablelib/ed25519 for Ed25519 cryptographic signing (JWT signatures for profile data)
- @noble/curves for ECDSA P-256 cryptographic signing (ephemeral WebView message signing)
- base64-js for base64 encoding/decoding
- esbuild for build-time JavaScript minification (WebView injection code)

## Troubleshooting

### Common Issues
- **Theme Issues**: Ensure components use themed components from UI directory
- **Navigation Problems**: Check route params and navigation structure; verify param lists in `/lib/navigation.ts`
- **Build Errors**: Update Expo SDK or check TypeScript errors with `yarn build`
- **WebView Injection Errors**: Run `yarn minify-webview` to regenerate minified JavaScript files after editing raw templates
- **Database Issues**: Check migration logs in console; ensure schema matches migration files in `/lib/db/migrations/`
- **API Issues**: Use function namespaces (`AppStateFns`, `UserProfileFns`, `ScanHistoryFns`) for database operations

### Debugging Tools
- React Native Debugger for runtime inspection
- Expo Dev Tools for device/emulator management
- TypeScript for compile-time checking
- `yarn test` for unit testing
- See `/docs/webview-console-forwarding.md` for details on how to enable console forwarding for WebView debugging in development.